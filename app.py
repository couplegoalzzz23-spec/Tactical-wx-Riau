# app.py
"""
Tactical Weather Ops — Pilot-Grade Streamlit Dashboard
Features:
- Fetch BMKG forecast API (adm1)
- METAR-style and short-TAF summary generation
- Runway selection and headwind/crosswind calculation
- Ceiling proxy from cloud-cover and flight-category (VFR/MVFR/IFR/LIFR)
- Decision summary (Takeoff / Landing / Alternate recommended)
- Alerts and thresholds
- QAM MET report HTML download
- Trend charts, windrose, simple radar tile placeholder
Author: Generated by assistant — adjust endpoints/fields to match your BMKG payload
"""

import streamlit as st
import requests
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import math
import base64
import html

# ---------------------------
# Page & style
# ---------------------------
st.set_page_config(page_title="Pilot-Grade Tactical Weather Ops", layout="wide")

STYLES = """
<style>
body { background-color:#0b0c0c; color:#cfd2c3; font-family: Inter, "Roboto", monospace; }
h1,h2,h3 { color:#9adf4f; letter-spacing:0.6px; text-transform:uppercase; }
.metric { background:#0f1111; border:1px solid #27382b; padding:10px; border-radius:8px; }
.badge { font-weight:700; padding:4px 8px; border-radius:6px; display:inline-block; }
.badge-ok { background:#b6ff6d; color:#002b00; }
.badge-caut { background:#ffd86b; color:#4a3b00; }
.badge-no { background:#ff6b6b; color:#2b0000; }
.small { color:#9fa8a0; font-size:0.85rem; }
.radar-placeholder { width:100%; height:300px; border-radius:8px; background:linear-gradient(90deg, rgba(50,60,50,0.05), rgba(20,25,20,0.05)); display:flex; align-items:center; justify-content:center; color:#7a7; border:1px dashed #2b3c2b; }
.codebox { background:#0a0b0a; padding:8px; border-radius:6px; border:1px solid #1e2b1e; color:#dfffe0; font-family: monospace; }
</style>
"""
st.markdown(STYLES, unsafe_allow_html=True)

# ---------------------------
# Constants & helpers
# ---------------------------
API_BASE = "https://cuaca.bmkg.go.id/api/df/v1/forecast/adm"
MS_TO_KT = 1.94384
METER_TO_SM = 0.000621371
METAR_TIME_FMT = "%d%H%MZ"

def safe_get(d, key, default="—"):
    return d.get(key, default) if isinstance(d, dict) else default

# Ceiling proxy from cloud cover (reuse logic you've used)
def ceiling_proxy_from_tcc(tcc_pct):
    if pd.isna(tcc_pct) or tcc_pct is None:
        return None, "Unknown"
    tcc = float(tcc_pct)
    if tcc < 1:
        return 99999, "SKC (Clear)"
    elif tcc < 25:
        return 3500, "FEW (>3000 ft)"
    elif tcc < 50:
        return 2250, "SCT (1500-3000 ft)"
    elif tcc < 75:
        return 1250, "BKN (1000-1500 ft)"
    else:
        return 800, "OVC (<1000 ft)"

def vis_to_sm(vis_m):
    try:
        vis_sm = float(vis_m) * METER_TO_SM
        return vis_sm
    except Exception:
        return None

def classify_flight_cat(vis_m, ceiling_ft):
    # using conservative thresholds
    vis_sm = None
    try:
        vis_sm = float(vis_m) * METER_TO_SM
    except:
        pass
    if vis_sm is None:
        return "Unknown"
    if vis_sm >= 8 and (ceiling_ft is None or ceiling_ft > 3000):
        return "VFR"
    if (3 <= vis_sm < 8) or (1000 < (ceiling_ft or 0) <= 3000):
        return "MVFR"
    if (1 <= vis_sm < 3) or (500 < (ceiling_ft or 0) <= 1000):
        return "IFR"
    if vis_sm < 1 or (ceiling_ft or 0) <= 500:
        return "LIFR"
    return "Unknown"

def wind_components(ws_kt, wind_dir_deg, rwy_deg):
    """
    Compute headwind and crosswind components (kt).
    Positive headwind = headwind, negative = tailwind.
    Crosswind positive = from right.
    """
    try:
        ws = float(ws_kt)
        wd = float(wind_dir_deg) % 360
        rwy = float(rwy_deg) % 360
    except:
        return None, None
    angle_diff = math.radians((wd - rwy + 540) % 360 - 180)  # shortest signed angle
    headwind = ws * math.cos(angle_diff)
    crosswind = ws * math.sin(angle_diff)
    return headwind, crosswind

def badge_html(text, kind="ok"):
    if kind == "ok":
        cls = "badge-ok"
    elif kind == "caut":
        cls = "badge-caut"
    else:
        cls = "badge-no"
    return f"<span class='badge {cls}'>{html.escape(str(text))}</span>"

def df_from_entry(entry):
    # flatten similar to user's flatten_cuaca_entry but minimal for UI; expects entry["cuaca"]
    rows = []
    lokasi = entry.get("lokasi", {})
    for group in entry.get("cuaca", []):
        for obs in group:
            r = obs.copy()
            r.update({
                "adm1": lokasi.get("adm1"),
                "adm2": lokasi.get("adm2"),
                "provinsi": lokasi.get("provinsi"),
                "kotkab": lokasi.get("kotkab"),
                "lon": lokasi.get("lon"),
                "lat": lokasi.get("lat"),
            })
            r["utc_datetime_dt"] = pd.to_datetime(r.get("utc_datetime"), errors="coerce")
            r["local_datetime_dt"] = pd.to_datetime(r.get("local_datetime"), errors="coerce")
            # numeric conversions
            for k in ["t","tcc","tp","wd_deg","ws","hu","vs"]:
                if k in r:
                    try:
                        r[k] = float(r[k])
                    except:
                        r[k] = np.nan
            rows.append(r)
    df = pd.DataFrame(rows)
    if df.empty:
        return df
    if "ws" in df.columns and "ws_kt" not in df.columns:
        df["ws_kt"] = df["ws"] * MS_TO_KT
    return df

# ---------------------------
# Caching fetch
# ---------------------------
@st.cache_data(ttl=180)
def fetch_forecast(adm1):
    params = {"adm1": adm1}
    resp = requests.get(API_BASE, params=params, timeout=8)
    resp.raise_for_status()
    return resp.json()

# ---------------------------
# Sidebar controls
# ---------------------------
with st.sidebar:
    st.title("Tactical Controls")
    adm1 = st.text_input("Province Code (ADM1)", value="32")
    icao = st.text_input("ICAO (for QAM)", value="WXXX", max_chars=4)
    st.markdown("---")
    runway = st.selectbox("Runway / Direction (deg)", options=["090","270","180","360","130","310"], index=0)
    rwy_deg = int(runway)
    st.markdown("Select runway azimuth used for wind component calc.")
    st.markdown("---")
    show_qam = st.checkbox("Show / Download QAM MET Report", value=True)
    st.markdown("---")
    time_range_hours = st.slider("Hours to show (trend)", min_value=3, max_value=72, value=12, step=3)

# ---------------------------
# Load BMKG data
# ---------------------------
st.title("✈️ Pilot-Grade Tactical Weather Ops")
st.markdown("Source: BMKG Forecast API — operational view for flight crews")

try:
    raw = fetch_forecast(adm1)
except requests.exceptions.HTTPError as e:
    st.error(f"API error: {e}")
    st.stop()
except Exception as e:
    st.error(f"Connection error: {e}")
    st.stop()

entries = raw.get("data", []) if isinstance(raw, dict) else []
if not entries:
    st.warning("No forecast data returned from API.")
    st.stop()

# Build mapping & select location
mapping = {}
for e in entries:
    lok = e.get("lokasi", {})
    label = lok.get("kotkab") or lok.get("adm2") or f"Loc {len(mapping)+1}"
    mapping[label] = e

col1, col2 = st.columns([3,1])
with col1:
    loc_choice = st.selectbox("Select Location / Aerodrome", options=list(mapping.keys()))
with col2:
    st.metric("Locations", len(mapping))

selected = mapping[loc_choice]
df = df_from_entry(selected)
if df.empty:
    st.warning("No observation rows for selected location.")
    st.stop()

# choose time column
if "local_datetime_dt" in df.columns and df["local_datetime_dt"].notna().any():
    df = df.sort_values("local_datetime_dt")
    time_col = "local_datetime_dt"
elif "utc_datetime_dt" in df.columns and df["utc_datetime_dt"].notna().any():
    df = df.sort_values("utc_datetime_dt")
    time_col = "utc_datetime_dt"
else:
    time_col = None

if time_col:
    end = df[time_col].max()
    start = end - timedelta(hours=time_range_hours)
    df_sel = df[(df[time_col] >= start) & (df[time_col] <= end)].copy()
else:
    df_sel = df.copy()

if df_sel.empty:
    st.warning("No forecast rows in selected time range.")
    st.stop()

# Focus on 'now' = nearest time to current
now_row = df_sel.iloc[0] if len(df_sel)==1 else df_sel.iloc[0]

# Metrics
t = now_row.get("t")
ws_kt = now_row.get("ws_kt") if "ws_kt" in now_row else (now_row.get("ws") * MS_TO_KT if now_row.get("ws") is not None else None)
wd_deg = now_row.get("wd_deg")
vs_m = now_row.get("vs")
tcc = now_row.get("tcc")
tp = now_row.get("tp")
hu = now_row.get("hu")
prov = now_row.get("provinsi", "")
kotkab = now_row.get("kotkab", "")
lat = now_row.get("lat", "")
lon = now_row.get("lon", "")
local_dt = now_row.get("local_datetime") or now_row.get("local_datetime_dt")

# Ceiling and flight category
ceiling_ft, ceiling_label = ceiling_proxy_from_tcc(tcc)
flight_cat = classify_flight_cat(vs_m, ceiling_ft)

# Wind components
hw, xw = wind_components(ws_kt or 0, wd_deg or 0, rwy_deg)
hw_display = f"{hw:.1f} kt" if hw is not None else "—"
xw_display = f"{abs(xw):.1f} kt {'from right' if xw>0 else 'from left' if xw<0 else ''}" if xw is not None else "—"

# Auto decision logic
def decision_summary(ws_kt, vs_m, ceiling_ft, tp_mm):
    takeoff = "Recommended"
    landing = "Recommended"
    reason = []
    # Wind limits conservative: >30kt no-go, 20-30 caution
    if ws_kt is not None and ws_kt >= 30:
        takeoff = landing = "Not Recommended"
        reason.append(f"High surface wind: {ws_kt:.1f} KT")
    elif ws_kt is not None and ws_kt >= 20:
        reason.append(f"Strong wind advisory: {ws_kt:.1f} KT")
    # visibility
    if vs_m is not None and vs_m < 1000:
        landing = "Not Recommended"
        reason.append(f"Low visibility: {vs_m:.0f} m")
    # rainfall accumulation
    if tp_mm is not None and tp_mm >= 20:
        takeoff = landing = "Caution"
        reason.append(f"Heavy accumulated rain ({tp_mm:.1f} mm) — potential runway contamination")
    elif tp_mm is not None and tp_mm > 5:
        reason.append(f"Moderate rain ({tp_mm:.1f} mm)")
    # ceiling
    if ceiling_ft is not None and ceiling_ft <= 500:
        landing = "Not Recommended"
        reason.append(f"Low cloud base ({ceiling_ft} ft)")
    if not reason:
        reason.append("Conditions within conservative operational limits.")
    return takeoff, landing, reason

takeoff_reco, landing_reco, reasons = decision_summary(ws_kt, vs_m, ceiling_ft, tp)

# Top panel (flight-centric)
st.markdown("---")
st.markdown("<div style='display:flex; gap:12px;'>", unsafe_allow_html=True)
# Left: Key metrics
colA, colB, colC, colD = st.columns([1.2,1,1,1])
with colA:
    st.markdown("### Key MET")
    st.markdown(f"<div class='metric'><strong>Temp:</strong> {t if pd.notna(t) else '—'} °C<br><span class='small'>Dewpoint est via RH</span></div>", unsafe_allow_html=True)
    st.markdown(f"<div class='metric' style='margin-top:8px;'><strong>Wind:</strong> {ws_kt:.1f if ws_kt else '—'} KT @ {wd_deg if not pd.isna(wd_deg) else '—'}°<br><span class='small'>Runway {rwy_deg} → HW {hw_display}, XW {xw_display}</span></div>", unsafe_allow_html=True)
with colB:
    st.markdown("### Sky / Visibility")
    vis_sm = vis_to_sm(vs_m)
    vs_text = f"{vs_m:.0f} m" if vs_m is not None and not np.isnan(vs_m) else "—"
    st.markdown(f"<div class='metric'><strong>Visibility:</strong> {vs_text} ({vis_sm:.1f} SM)</div>", unsafe_allow_html=True)
    st.markdown(f"<div class='metric' style='margin-top:8px;'><strong>Ceiling:</strong> {ceiling_label} / {ceiling_ft if ceiling_ft is not None else '—'} ft</div>", unsafe_allow_html=True)
with colC:
    st.markdown("### Weather")
    st.markdown(f"<div class='metric'><strong>Weather:</strong> {now_row.get('weather_desc','—')}<br><strong>Rain acc:</strong> {tp if not np.isnan(tp) else 0:.1f} mm</div>", unsafe_allow_html=True)
with colD:
    st.markdown("### Operational")
    st.markdown(f"<div class='metric'><strong>Flight Cat:</strong> {badge_html(flight_cat, 'ok' if flight_cat=='VFR' else 'caut' if flight_cat=='MVFR' else 'no')}</div>", unsafe_allow_html=True)
    st.markdown(f"<div style='margin-top:6px;' class='metric'><strong>Takeoff:</strong> {badge_html(takeoff_reco, 'ok' if takeoff_reco=='Recommended' else 'no' if takeoff_reco=='Not Recommended' else 'caut')}<br><strong>Landing:</strong> {badge_html(landing_reco, 'ok' if landing_reco=='Recommended' else 'no' if landing_reco=='Not Recommended' else 'caut')}</div>", unsafe_allow_html=True)
st.markdown("</div>", unsafe_allow_html=True)
st.markdown("---")

# Rationale / short summary (one-sentence)
summary_sent = f"{flight_cat} conditions. Wind {ws_kt:.1f if ws_kt else '—'} KT at {wd_deg if not pd.isna(wd_deg) else '—'}°. Runway {rwy_deg} headwind {hw_display}, crosswind {xw_display}. {', '.join(reasons[:2])}"
st.info(f"Decision Summary — {summary_sent}")

# Detailed rationale
st.markdown("**Rationale / Notes:**")
for r in reasons:
    st.markdown(f"- {r}")

# METAR-style generator (concise)
def generate_metar(now, icao_code, rwy_deg):
    """
    Build a concise METAR-like string using available fields.
    NOTE: This is a best-effort synthetic METAR for operational readability (not official).
    """
    time_utc = now.get("utc_datetime") or now.get("utc_datetime_dt")
    try:
        dt = pd.to_datetime(time_utc)
        time_token = dt.strftime("%d%H%M") + "Z"
    except:
        time_token = "000000Z"
    wind = f"{int(round(now.get('wd_deg',0))):03d}{int(round(now.get('ws_kt',0))):02d}KT" if not pd.isna(now.get('wd_deg', np.nan)) else "00000KT"
    vis = f"{int(round(now.get('vs',9999)))}m"
    wx = now.get("weather_desc","-")
    t = f"{int(round(now.get('t',0))):02d}/{int(round((now.get('t',0)-((100-now.get('hu',50))/5))) if now.get('hu') is not None else 0):02d}" if now.get('t') is not None else "///"
    metar = f"{icao_code} {time_token} {wind} {vis} {wx} {t} QNH_NA"
    return metar

metar_text = generate_metar(now_row, icao, rwy_deg)
st.markdown("### METAR-style (synthetic)")
st.markdown(f"<div class='codebox'>{html.escape(metar_text)}</div>", unsafe_allow_html=True)

# Trend charts
st.markdown("## Trends")
c1, c2, c3 = st.columns(3)
with c1:
    fig_t = px.line(df_sel, x=time_col, y="t", title="Temperature (°C)")
    st.plotly_chart(fig_t, use_container_width=True)
with c2:
    fig_w = px.line(df_sel, x=time_col, y="ws_kt", title="Wind (KT)")
    st.plotly_chart(fig_w, use_container_width=True)
with c3:
    if "tp" in df_sel.columns:
        fig_r = px.bar(df_sel, x=time_col, y="tp", title="Rainfall (mm)")
        st.plotly_chart(fig_r, use_container_width=True)

# Windrose (if adequate data)
st.markdown("## Windrose")
if {"wd_deg","ws_kt"}.issubset(df_sel.columns) and not df_sel[["wd_deg","ws_kt"]].dropna().empty:
    df_wr = df_sel.dropna(subset=["wd_deg","ws_kt"]).copy()
    bins = np.arange(-11.25,360,22.5)
    labels = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"]
    df_wr["dir_sector"] = pd.cut(df_wr["wd_deg"] % 360, bins=bins, labels=labels, include_lowest=True)
    speed_bins = [0,5,10,20,30,50,100]
    speed_labels = ["<5","5-10","10-20","20-30","30-50",">50"]
    df_wr["speed_class"] = pd.cut(df_wr["ws_kt"], bins=speed_bins, labels=speed_labels, include_lowest=True)
    freq = df_wr.groupby(["dir_sector","speed_class"]).size().reset_index(name="count")
    if not freq.empty:
        freq["percent"] = freq["count"] / freq["count"].sum() * 100
        az_map = {lab: i*22.5 for i, lab in enumerate(labels)}
        freq["theta"] = freq["dir_sector"].map(az_map)
        fig_wr = go.Figure()
        colors = ["#00ffbf","#80ff00","#d0ff00","#ffb300","#ff6600","#ff0033"]
        for i, sc in enumerate(speed_labels):
            subset = freq[freq["speed_class"]==sc]
            fig_wr.add_trace(go.Barpolar(
                r=subset["percent"], theta=subset["theta"],
                name=f"{sc} KT", marker_color=colors[i] if i < len(colors) else None, opacity=0.85
            ))
        fig_wr.update_layout(title="Windrose (%)", template="plotly_dark", polar=dict(angularaxis=dict(direction="clockwise", rotation=90)))
        st.plotly_chart(fig_wr, use_container_width=True)
    else:
        st.info("Insufficient wind data for windrose")
else:
    st.info("Wind data not available for windrose")

# Radar / Convective placeholder
st.markdown("## Radar / Convective (Placeholder)")
st.markdown("<div class='radar-placeholder'>Radar tiles or NRT convective overlay can be embedded here (requires external tiles or WMS).</div>", unsafe_allow_html=True)
st.markdown("Tip: integrate BMKG radar tiles / reflectivity if you have a WMTS or tile URL. Or stream WRF/HRRR overlays.")

# QAM MET report (download)
if show_qam:
    st.markdown("---")
    st.markdown("## QAM MET Report (Downloadable)")
    qam_html = f"""
    <html><head><meta charset='utf-8'><title>MET_REPORT_{loc_choice}</title></head><body style='font-family:Arial; background:#0b0c0c; color:#dfffe0;'>
    <h2>METEOROLOGICAL REPORT FOR TAKE OFF AND LANDING</h2>
    <table border='1' cellpadding='6' style='border-collapse:collapse; color:#dfffe0;'>
      <tr><th>Station</th><td>{html.escape(icao)} / {html.escape(loc_choice)}</td></tr>
      <tr><th>Time</th><td>{html.escape(str(now_row.get('local_datetime','—')))} (Local) / {html.escape(str(now_row.get('utc_datetime','—')))} (UTC)</td></tr>
      <tr><th>Surface wind</th><td>{int(round(wd_deg)) if not pd.isna(wd_deg) else '—'}° / {ws_kt:.1f if ws_kt else '—'} KT (HW {hw_display}, XW {xw_display})</td></tr>
      <tr><th>Visibility</th><td>{vs_m if not np.isnan(vs_m) else '—'} m ({vis_sm:.1f if vis_sm else '—'} SM)</td></tr>
      <tr><th>Present weather</th><td>{html.escape(str(now_row.get('weather_desc','—')))} (Rain acc: {tp if not np.isnan(tp) else 0:.1f} mm)</td></tr>
      <tr><th>Cloud</th><td>{ceiling_label} / {ceiling_ft if ceiling_ft is not None else '—'} ft</td></tr>
      <tr><th>Temp / Dewpoint</th><td>{t if not np.isnan(t) else '—'} °C / Dewpoint est: {'—'}</td></tr>
      <tr><th>Decision</th><td>Takeoff: {takeoff_reco} — Landing: {landing_reco}</td></tr>
      <tr><th>Notes</th><td>{html.escape('; '.join(reasons))}</td></tr>
    </table>
    </body></html>
    """
    b64 = base64.b64encode(qam_html.encode()).decode()
    href = f'<a href="data:text/html;base64,{b64}" download="MET_REPORT_{loc_choice}.html">⬇ Download QAM MET Report (HTML)</a>'
    st.markdown(href, unsafe_allow_html=True)

# Export selected forecast table as CSV/JSON
st.markdown("---")
colx, coly = st.columns(2)
with colx:
    csv = df_sel.to_csv(index=False)
    st.download_button("⬇ Download CSV (selection)", data=csv, file_name=f"{loc_choice}_forecast.csv", mime="text/csv")
with coly:
    json_text = df_sel.to_json(orient="records", force_ascii=False, date_format="iso")
    st.download_button("⬇ Download JSON (selection)", data=json_text, file_name=f"{loc_choice}_forecast.json", mime="application/json")

# Footer
st.markdown("---")
st.markdown("<div style='text-align:center; color:#7a7;'>Pilot-Grade Tactical Weather Ops — BMKG Data © 2025</div>", unsafe_allow_html=True)
